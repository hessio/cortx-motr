#+TITLE: Distributed transaction manager high level design (draft)
#+AUTHOR: DTM Team, Anatoliy Bilenko
#+DATE: 28-12-2020



This document presents a high level design (HLD) of distributed
transaction management component for Motr. The main purposes of this
document are: (i) to be inspected by Motr, HA and HARE architects and peer
designers to ascertain that high level design is aligned with Motr, HA and
HARE architecture and other designs, and contains no defects, (ii) to
be a source of material for Active Reviews of Intermediate Design
(ARID) and detailed level design (DLD) of the same component, (iii) to
serve as a design reference document.

The intended audience of this document consists of Motr, HA and HARE
customers, architects, designers and developers.

* Revision history
|   | Version | Date             | Author   | Desciption of changes                     |
|---+---------+------------------+----------+-------------------------------------------|
|   |   0.0.1 | <2020-12-28 Mon> | Anatoliy | Initial                                   |
|   |   0.0.2 | <2020-12-29 Tue> | Anatoliy | Added significant sections                |
|   |   0.0.3 | <2020-12-29 Tue> | Anatoliy | Added usecases worked through by the team |
* Approvals
|   | Version | approving person | Signature, date |
|---+---------+------------------+-----------------|
|   |   0.0.1 |                  |                 |
* Introduction
#+BEGIN_QUOTE
=[This section succinctly introduces the subject matter of the design. 1--2 paragraphs]=
#+END_QUOTE

This document describes high level implementation details of metadata
DTM or DTM0 including protocol properties, interraction with related
components such as HA, DTM user (S3), constrains, assumptions and
usecases. DTM0 is intended to addresses scalability, durability,
availablility and other requirements of MRD and explains how to reach
them.

* Definitions
#+BEGIN_QUOTE
=[Definitions of terms and concepts used by the design go here. The definitions must be as precise as possible. References to the Mero Glossary are permitted and encouraged. Agreed upon terminology should be incorporated in the glossary]=
#+END_QUOTE

** process

Operating system process which is under the track of HA that can be
associated with defined set of process states.
** process state

State in sense of availability of an arbitrary software or hardware
component of motr treated by HA and SEEN on the process level. It's
assumed that process with the help of HA can distinguish ONLINE,
TRANSIENT, FAILED, REPAIRING states.
** motr process

Processes related to DTM0 algorithm.
** motr HA

High availability subsystem of motr responsible for orchestration of
motr processes. Orchestration itself is a process of communication
between HA and motr processes by sending corresponding messages and
signals (kill, start, restart). Processes involved into orchestration
and HA itself follow specific logic seen outside and which can be
tracked by a chain of processes state changes.
** motr service

A part of motr process responsible for sending, receiving and reaction
on HA and DTM messages along with other specific activities (IO
services, RM services, etc).
** message

motr RPC item (one-way or request-reply) sent from one process and
delivered to another via RPC protocol, having appropriate properties,
attributes and payloads.
** HA message

Different types of messages sent in between motr services and motr HA
accordingly to orchestration protocol of communication. Such messages,
sent from HA to process, carry information about process states
(process_x goes ONLINE) and messages-triggers, sent in bidirectional
manner w.r.t. to update process state at all ends of communication (HA
sends "start recovery" message, process sends "recovery complete"
message).
** DTM0

Distributed transaction manager is a component or an algorithm
maintaining consistency of storage replicas of *motr metadata* in
distributed system in face of failures simplifying handling such
failures by means of hiding failure processing logic and providing a
distributed transactional interface with a specific semantics to the
user.
** DTM0 message

Different types of messages sent in between DTM0 services accordingly
to DTM0 protocol of the communication. Payloads of these messages may
contain modification requests to persistent state stored on underlying
storage (PUT, DEL, REDO, etc.), service information (participants, dtx
id, version, etc.), acknowledgments messages (PERSISTENT, EXECUTED,
etc.).
** dtx

Distributed transaction is a unit of modification of the distributed
state (metadata replicas for DTM0) for the whole distributed system
performed and treated in a reliable and coherent manner complying with
the atomicity and durability properties (no isolation and consistency
for DTM0). Keeping track of dependencies is performed by the dtx usage
semantics on the originator side and will be covered later.

** dtx state

The state of the dtx is seen in many places in the system still
treated on the originator side. dtx itself limits states to EXECUTED,
PERSISTENT, STABLE, DONE which will be covered later.

** txr

Distributed transaction record is a payload of DTM0 message, delivered
onto participants of dtx with persistent state via DTM0 messages
onto DTM0 services by any possible means (inside CAS request data or
as a separate network message, etc.). It includes list of dtx
participants, information regarding underlying operation (PUT, DEL,
etc.) complete enough to execute this operation locally and without
any network communication with any other participants and to reach the
persistent effect.

** operation

Underlying operation for DTM0 is a request to motr metadata CAS
service to transactional update the underlying state of metadata
storage (PUT, DEL, etc.) provided by any possible means either by
sending messages over the network or by performing execution of local
to the process FOM.

Operation is being performed in the context of local transaction.
** update

Part of an operation that a remote Mero instance must execute is called an update.
** local transaction

a transaction is a collection of modifications of persistent state.
closed transaction is atomic with respect to process crashes that
happen after transaction close call returns.

** participant

a process, sending, receiving DTM0 messages and executing underlying
operations w.r.t. DTM0 algorithm. Participant may have persistent and
volatile state.
** originator

a process, a special kind of participant which initiates distributed
transaction and receives results of local data modifications (PUT,
DEL, etc) related to its context.
** recovery

a process of communication accordingly to DTM0 protocol between DTM0
services by means of DTM0 messages and execution of underlying
operations initiated by HA. The goal of recovery process is to restore
consistency of the distributed state across distributed system replicas.
** failure

Loss of persistent or/and volatile state of the process or its parts.
Seen on participant by receiving corresponding HA messages with the
process state changes. Treated and identified on HA side only
accrodingly to HA internal logic.
** transient failure

Failure recoverable with DTM0 (process crash, restart, etc.)
** permanent failure

Failure unrecoverable with DTM0 (storage controller failure, etc.)
** dependency

There's not explicit dependency treatment in DTM0 design, still such
dependencies can be injected on the originator side and treated on the
participant side by means of ordering dtxs in time. For example,
originator may wait until dtx1 gets to STABLE state before executing
dtx2.
** clock

an algorithm used to generate versions and tx ids in distributed system
having property of the order.
** version

a special number used for application of operations in specific order
supporting ordering operator.
** log

DTM0 log, persistent structure used by DTM0 algorithm to provide recovery.
** persistent state

Persistent data stored in underlying storage.
** volatile state

Volatile data stored in RAM.
** tombstone

is a special metadata record indicating that normal key and value
record were deleted some time ago and can be interpreted during DTM0
recovery and other modes.

* Requirements & assumptions
#+BEGIN_QUOTE
=[This section enumerates requirements collected and reviewed at the Requirements Analysis (RA) and Requirements Inspection (RI) phases of development. References to the appropriate RA and RI documents should go here. In addition this section lists architecture level requirements for the component from the Summary requirements table and appropriate architecture documentation]=
#+END_QUOTE
** [A.dtm0.ad-tx]
Transactions support atomicity and durability only.
** [A.dtm0.1-op]
DTM0 supports only one operation (PUT, DEL, etc) in a single dtx.
** [A.dtm0.txr]
A single record shall have enough data to restore consistency in all
replicas. Therefore dtx is fully described by a single txr. A txr
contains the list of participants and a participant can
deterministically execute its part of transaction based on txr without
communicating with other participants

** [A.dtm0.no-dep]
DTM0 doesn't have explicit dependency tracking and dependencies
between operations can be introduced by ordering their execution and
stabilisation with an appropriate DTX interface. Additionally to
mentioned above if it's needed users of DTM0 should track any other
dependency except order by themselves.
** [A.no-undo]
DTM0 algo doesn't support undo of the operation but may support it in
future.
** [A.dix.no-spares]
DIX doesn't use spares in the DTM0 algorithm may be extendend in the
future.
** [A.ha.failures]
Motr doesn't treat failures types and relies on HARE.
** [A.dtm0.failures]
DTM0 algorithm treats transient failures only
** [A.rpc.timeout]
Timeout is not a failure
** [A.dtm0.permanent.failures]
DTM0 supports handling of not more that K+1 permanent failures during
the period of interest. In cases when previous failures are being
repaired by DTM and new occurs, the previous one is treated as transient.
** [A.rpc.magic-link]
RPC resends messages untill it get stopped by HA message. see
A.rpc.timeout.
** [A.dix.no-vectored]
Due to complexity of imask value distribution, DTM0 doesn't support
vectored dix operations transmitting several keys and values to the
counterpart.

** [A.clock.sync]
DTM0 relies on the synchronised 'physical' clock over all nodes and
not responsible to setting these clocks.
** [A.clock.desync]
In case of desyncronisation of clocks DTM0 shall not corrupt metadata
still not responsible for setting the clock.

** [A.dtx.cancel]
DTM0 doesn't support cancelation of DTXs.
** [A.HA.messages]
DTM0 introduces new HA related messages that need to be reacted
properly on HA side.
** [A.S3.integration]
DTM0 design is not responsible for the definition of flawless S3
integration procedure including IO data path failures which are not in
the scope of DTM0.
** [R.dtm0.log.payload]
DTM0 log may contain long-living data
** [R.dtm0.versioning]
Conflict resolution algorithm is based on top of versions numbers
which can be easily compared. A participant can deterministically tell
whether it already executed the dtx.
** [A.dtm0.fairness]
The period of failure occurence statistically is much longer than dtm0 recovery time.

** [A.originator.failure]
Originator failure is treated as a permanent failure

** [A.ha.failure-model]
Failure model is not defined by DTM0 design, still DTM0 code has to
distinguish at least the following states of the participants: ONLINE,
TRANSIENT, FAILED, RECOVERING.

** [A.ha.EOS]
HA provides exactly one semantics including and not excluding the
following usecase: before, after and during the time of transient
failure of the participant all HA messages regarding cluster state
changes delivered on other online participants shall be delivered to
the failing participant after it gets online in the same order they
were delivered to others.

* Design highlights
#+BEGIN_QUOTE
=[This section briefly summarises key design decisions that are important for understanding of the functional and logical specifications and enumerates topics that a reader is advised to pay special attention to]=
#+END_QUOTE

* Functional specification
#+BEGIN_QUOTE
=[This section defines a functional structure of the designed component: the decomposition showing *what* the component does to address the requirements]=
#+END_QUOTE

=[interface]= DTM0 component interracts with the user (clovis
interface user, s3 server) by means of the asynchronous dtx interface
integrated into clovis interface, interracts with other motr processes
or so-called participants of dtx by means of trasmitting DTM0
messages, interracts with HA by means of transmitting HA messages.

=[input]= The user attaches txr to outgoing DTM0 message transmitted
to the participants. Internally delivery, reply and other state changes
related to DTM0 messages trigger dtx state change which might be
observed during interraction with dtx interface. Error codes might be
returned to the user via dtx attributes.

=[output]= On the component level interraction can be seen as a flow
of HA and DTM0 messages and persistent state changes.

** dtx interface
Provides a way to *open* a [[*dtx][dtx]], *add* an [[*operation][operation]] (PUT, DEL, etc) to
dtx, to *commit* the dtx so that it goes into processing, to
*subscribe* or *wait* until dtx moves into specific state and to
*finalise* dtx.

The following states and their semantics can be relevant to dtx still
the list can be non-full:
 - *EXECUTED* one or more [[*operation][operations]] have been executed in volatile
   memory of the participant, the result of such execution is known
   and returned to the dtx user.
 - *STABLE* sufficient number of sent [[*operation][operations]] have been "persisted"
   on the remote end which guarantees survivial of persistent
   failures.
 - *DONE* all sent [[*operation][operations]] have been "persisted" on sufficient
   number of non-failed participants.

** DTM0 messages
For all scenarios DTM0 protocol identifies the following set of messages:
 - *txr* message is being used to send operations which have to be
   executed on the participants.
 - *EXECUTED* message is being sent from the given participant to the
   originator of dtx, can be a part of *txr* reply message, it's being
   sent when the operation has been executed inside the participant's
   memory and result of the operation is known (e.g. key exists in the
   btree, etc.).
 - *PERSISTENT* message is being sent from the given participant with
   persistent storage to all other participants of dtx when the
   operation effects get persisted (synced to the underlying storage)
   on the given participant.
 - *REDO* message is being used to resend *txr* messages during DTM0
   recovery and being sent from ONLINE participants of the dtx to
   RECOVERING.

** HA messages
Besides existing HA messages like entry point requests/replies, DTM0
algorithm assumes that the following will be introduced and
implemented in HA:
- *participant state change message*, is being sent from HA to participants
  (example: participant_1 goes to RECOVERING state)
- *"participant is ready for the recovery"*, is being sent from the
  participant to HA when it's ready to accept REDO messages from other
  participants (example: participant gets connected to others).
- *recovery DONE*, is being sent from the participant to HA when it
  has completed the recovery or recovery has failed for any reason.

** Persistent state changes
Different persistent strucutres updates including and not excluding
local BE transactional updates to DTM0 log and CAS service indexes.

* Logical specification
#+BEGIN_QUOTE
=[This section defines a logical structure of the designed component: the decomposition showing how the functional specification is met. Subcomponents and diagrams of their interrelations should go in this section]=
#+END_QUOTE

basic scenarios:
 - startup
 - shutdown
 - happy path
 - P transient failures of any participants and recovery
 - Q permanent failures of any participants

** Conformance
=[For every requirement in the Requirements section, this sub-section explicitly describes how the requirement is discharged by the design. This section is part of a requirements tracking mechanism, so it should be formatted in some way suitable for (semi-)automatic processing]=
** Dependencies
=[This sub-section enumerates other system and external components the component depends on. For every dependency a type of the dependency (uses, generalizes, etc.) must be specified together with the particular properties (requirements, invariants) the design depends upon. This section is part of a requirements tracking mechanism]=
** Refinement
=[This sub-section enumerates design level requirements introduced by the design. These requirements are used as input requirements for the detailed level design of the component. This sub-section is part of a requirements tracking mechanism]=
* State
=[This section describes the additions or modifications to the system state (persistent, volatile) introduced by the component. As much of component behavior from the logical specification should be described as state machines as possible. The following sub-sections are repeated for every state machine]=

** States, events, transitions
=[This sub-section enumerates state machine states, input and output events and state transitions incurred by the events with a table or diagram of possible state transitions. UML state diagrams can be used here]=
** State invariants
=[This sub-section describes relations between parts of the state invariant through the state modifications]=
** Concurrency control
=[This sub-section describes what forms of concurrent access are possible and what forms on concurrency control (locking, queuing, etc.) are used to maintain consistency]=
* Use cases
=[This section describes how the component interacts with rest of the system and with the outside world]=
** Scenarios
=[This sub-section enumerates important use cases (to be later used as seed scenarios for ARID) and describes them in terms of logical specification]=
** Failures
=[This sub-section defines relevant failures and reaction to them. Invariants maintained across the failures must be clearly stated. Reaction to Byzantine failures (i.e., failures where a compromised component acts to invalidate system integrity) is described here]=
* Analysis
** Scalability
=[This sub-section describes how the component reacts to the variation in input and configuration parameters: number of nodes, threads, requests, locks, utilization of resources (processor cycles, network and storage bandwidth, caches), etc. Configuration and work-load parameters affecting component behavior must be specified here]=
** Other
=[As applicable, this sub-section analyses other aspects of the design, e.g., recoverability of a distributed state consistency, concurrency control issues]=
** Rationale
=[This sub-section describes why particular design was selected; what alternatives (alternative designs and variations of the design) were considered and rejected]=
* Deployment
** Compatibility
=[Backward and forward compatibility issues are discussed here. Changes in system invariants (event ordering, failure modes, etc.)]=
*** Network
*** Persistent storage
*** Core
=[Interface changes. Changes to shared in-core data structures]=
** Installation
=[How the component is delivered and installed]=
* References
=[References to all external documents (specifications, architecture and requirements documents, etc.) are placed here. The rest of the document cites references from this section. Use Google Docs bookmarks to link to the references from the main text]=
