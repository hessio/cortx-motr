
/*
Allowed transitions:
        CRASHED -----------> RECOVERING -------------> ONLINE;
	/|\                                              |
         +-----------------------------------------------+

Timelines and periods:

st=ONLINE     st=CRASHED             st=RECOVERING          st=ONLINE
|-------X-----|----------------------|----------------------|--------> t
        |        ("boot" period)         ("grace" period)     ("normal" mode)
        |
     (actual crash)

*/


// Types -- verified by invariants or a type system (if there any).
struct redo_state_item {
	fid  node;
	bool is_done;
};

// In-memory states (state machines)
variable: redo_state, state space: any possible value of redo_state_item[N],
	where N depends on @T and it is in the range 0..NR_NODES.
variable: HA; // opaque object that generates HA events
variable: NETWORK; // opaque object that sends/receives REDO messages
variable: DTM; // opaque object that wraps around DTM log and CAS service

/* TODO: redo_state has to be a part of separate array of variables
	that represent volatile state of each participant
*/

// Transistions of in-memory states

// This function affects redo_state variable
redo_state.on_ha_event(RECOVERING self) {
	assume: HA.prev_state() == CRASHED;

	redo_state = HA.get_online_dones().map(\n -> (n.fid, false));
}

(DTM|HETWORK).redo_fom_ver1(!ONLINE other){
	// Find the last record to send
	prev_record = NULL
	last_record = NULL;
	for record in DTM.log {
		// Some magic with prev and current records
		// .........
		// may be omitted here.
		if record.time > HA.recovery_start_time(other) {
			last_record = prev_record;
			break;
		}
	}

	msg.src = self;
	msg.tgt = other;

	for record in DTM.log {
		if (!record.has_pa(other) ||
		    record.has_persistent_msg(other)) {
			continue;
		}
		// Can use batching of records here
		msg.dtx = record.dtx;
		msg.is_last = record == last_record;
		NETWORK.send(msg);
		await NETWORK.recv(ack);
		// Execution is synchrnonous but
		// we still have to match acks.
		assume: ack.dtx.tx_id == msg.dtx.tx_id.
		if (record == last_record)
			break;
	}
}

(DTM|HETWORK).redo_fom_ver2(!ONLINE other){
	msg.src = self;
	msg.tgt = other;
	for record in DTM.log {
		if (record.time > HA.recovery_start_time(other))
			break;

		if (!record.has_pa(other) ||
		    record.has_persistent_msg(other)) {
			continue;
		}

		// Can use batching of records here
		msg.dtx = record.dtx;
		NETWORK.send(msg);
		await NETWORK.recv(ack);
		// Execution is synchrnonous but
		// we still have to match acks.
		assume: ack.dtx.tx_id == msg.dtx.tx_id.
	}
	DTX.redo_complete_msg.src = self;
	DTX.redo_complete_msg.tgt = other;
	NETWORK.send(DTX.redo_complete_msg);
	await NETWORK.recv(ack);
}

// This function affects only NETWORK variable
(NETWORK).on_ha_event(!ONLINE other) {
	assume: self != other;
	if (HA.is_recovering(self)) {
		redo_state.remove(other.fid);
		return;
	}

	if (HA.is_online(self) && HA.is_recovering(other))
		if ((DTM|HETWORK).redo_fom_ver1)
			// With "is_last" field inside of each packet
			enque((DTM|HETWORK).redo_fom_ver1);
		else
			// With the separate completion packet
			enque((DTM|HETWORK).redo_fom_ver2);
}

// This function affects DTM, NETWORK and HA variables
(NETWORK|DTM|HA).on_recv(REDO msg) {
	assume: The message was sent to us.
	assume: Execution is synchronous: acks sent only after a message
	is processed; there is no way to execute the last record
	before all the previous records are executed.
	assume: HA.is_online(msg.src).

	DTM.apply(msg);
	if (msg_with_is_last_field)
		redo_state[msg.src].is_done = msg.is_last;
	ack = { .dtx = msg.dtx, .reply = msg.reply };
	await NETWORK.send(msg); // may include a reply, see DTM.apply

	if (msg_with_is_last_field) {
		if (redo_state[msg.src].is_done)
			redo_state.remove(msg.src);

		if (redo_state.is_empty())
			// The node "self" has been fully recovered.
			HA.consider_st_transition(self, ONLINE, now())
	}
}

(NETWORK|DTM|HA).on_recv(REDO_COMPLETE msg) {
	assume: The message was sent to us.

	redo_state.remove(msg.src);

	if (redo_state.is_empty())
		// The node "self" has been fully recovered.
		HA.consider_st_transition(self, ONLINE, now())

// This function affect only the state of DTM variable
DTM.apply(msg) {
	record = DTM.lookup(msg.tx_id())
	if record.is_none() {
		msg.reply = DTM.CAS.execute(msg);
	} else {
		if msg.src.is_reply_required() {
			msg.reply = record.reply;
		}
	}
	DTM.log_update_state(msg.tx_id(), msg.states());
	async DTM.log_commit(msg.tx_id());
}

